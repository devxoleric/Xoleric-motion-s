<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Xoleric World's</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŒ€</text></svg>">
</head>
<body>

  <!-- Open Graph (Facebook, Telegram, WhatsApp, Discord) -->
  <meta property="og:title" content="Xoleric project">
  <meta property="og:description" content="Xoleric project sahifasi">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://devxoleric.github.io/I-xoleric-/">
  <meta property="og:image" content="https://devxoleric.github.io/I-xoleric-/preview.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Xoleric project">
  <meta name="twitter:description" content="Xoleric project sahifasi">
  <meta name="twitter:image" content="https://devxoleric.github.io/I-xoleric-/preview.png">

  <style>
    html, body {
      height: 100%; margin: 0; overflow: hidden;
      background: #000; touch-action: none;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    (() => {
      const { sin, cos, hypot, max, min, PI, random } = Math;
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      let w = 0, h = 0;
      function resize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const cssW = window.innerWidth;
        const cssH = window.innerHeight;
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        w = canvas.width;
        h = canvas.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.translate(w / 2, h / 2);
        ctx.scale(w, w);
      }
      resize();
      addEventListener('resize', resize);

      const rnds = (x = 1) => random() * x - x / 2;
      const pt = (x, y) => ({ x, y });
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpPt = (a, b, t) => pt(lerp(a.x, b.x, t), lerp(a.y, b.y, t));
      const many = (n, f) => Array.from({ length: n }, (_, i) => f(i));
      const smoothstep = t => 3 * t * t - 2 * t * t;

      function tentacle(from, to, t) {
        const count = 60;
        t = smoothstep(t);
        for (let i = 0; i < count; i++) {
          let x = i / count;
          if (x > t) return;
          let p = lerpPt(from, to, x);
          let r = ((x - 0.5) ** 2 + 0.1) ** 2 * 0.015;
          ctx.beginPath();
          ctx.arc(p.x, p.y, r, 0, PI * 2);
          ctx.fill();
        }
      }

      function thing(id) {
        return {
          id,
          pos: { x: rnds(0.2), y: rnds(0.2) },
          target: { x: 0, y: 0 },
          hue: id * 180,
          pts: many(100, () => ({ x: rnds(0.6), y: rnds(0.6), t: 0 })),
          tick(t) {
            this.hue = (this.hue + 1) % 360;
            ctx.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
            this.pos.x += (this.target.x - this.pos.x) / (15 + id * 5);
            this.pos.y += (this.target.y - this.pos.y) / (15 + id * 5);

            const c = pt(this.pos.x, this.pos.y);
            this.pts.forEach(p => {
              const dist = hypot(p.x - this.pos.x, p.y - this.pos.y);
              const grow = dist < 0.12;
              p.t = max(min(1, p.t + (grow ? 0.04 : -0.06)), 0);
              if (p.t > 0) tentacle(c, p, p.t);
            });
          }
        };
      }

      const things = [thing(0), thing(1)];
      let lastPointer = 0;

      addEventListener("pointermove", e => {
        const cssW = window.innerWidth;
        const x = (e.clientX - cssW / 2) / cssW;
        const y = (e.clientY - window.innerHeight / 2) / cssW;
        lastPointer = performance.now();
        things[0].target = { x: x - 0.05, y: y - 0.05 };
        things[1].target = { x: x + 0.05, y: y + 0.05 };
      });

      requestAnimationFrame(function frame(t) {
        t /= 1000;
        ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        if (performance.now() - lastPointer > 2000) {
          things.forEach((th, i) => {
            th.target.x = cos(t * 0.5 + i) * 0.2;
            th.target.y = sin(t * 0.7 + i) * 0.2;
          });
        }

        things.forEach(th => th.tick(t));
        requestAnimationFrame(frame);
      });
    })();
  </script>
</body>
</html>
